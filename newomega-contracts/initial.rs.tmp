#![cfg_attr(not(feature = "std"), no_std)]

use ink_lang as ink;
use std::cmp;

#[ink::contract]
mod GameEngineLibrary {
    pub const BOARD_SIZE: i8 = 15;
    pub const MAX_ROUNDS: i8 = 50;
    pub const MAX_SHIPS: i8 = 4;
    pub const FIT_TO_STAT: u8 = 20;

    pub struct Move {
        moveType: u8,
        round: u8,
        source: u8,
        target: u8,
        targetPosition: i8,
        damage: u32
    }

    pub struct ShipVariableStat {
        base: u16,
        variable: u16
    }

    pub struct Ship {
        cp: u16,
        hp: u16,
        attack: ShipVariableStat,
        defence: u16,
        speed: u16,
        range: u16
    }

    pub struct FightResult {
        selectionLhs: [u8; MAX_SHIPS],
        selectionRhs: [u8; MAX_SHIPS],
        variantsLhs: [u8; MAX_SHIPS],
        variantsRhs: [u8; MAX_SHIPS],
        commanderLhs: u8,
        commanderLhs: u8,
        lhs: Vec<Move>,
        rhs: Vec<Move>,
        lhsDead: bool,
        rhsDead: bool,
        rounds: u8,
        seed: u64,
        shipsLostLhs: [u8; MAX_SHIPS],
        shipsLostRhs: [u8; MAX_SHIPS]
    }

    impl GameEngineLibrary {
        #[ink(constructor)]
        pub fn new() -> Self {
            Self { }
        }

        #[ink(constructor)]
        pub fn default() -> Self {
            Self::new(Default::default())
        }

        fn isDead(&self, shipHps: [i32; MAX_SHIPS]) -> bool {
            let isTargetDead = true;

            for i in 0..MAX_SHIPS {
                if (shipHps[i] > 0) {
                    isTargetDead = false;
                }
            }

            isTargetDead
        }

        fn getDefenceStat(&self, stat: u16, variant: u8) -> u16 {
            let finalStat: u16 = 0;

            match variant {
                0 => finalStat = stat,
                1 => finalStat = stat + FIT_TO_STAT,
                2 => finalStat = stat - FIT_TO_STAT
            }

            finalStat
        }

        fn getAttackStat(&self, stat: u16, variant: u8) -> u16 {
            let finalStat: u16 = 0;

            match variant {
                0 => finalStat = stat,
                1 => finalStat = stat - FIT_TO_STAT,
                2 => finalStat = stat + FIT_TO_STAT
            }

            finalStat
        }

        fn getTarget(&self, Ships: [Ship; MAX_SHIPS], currentShip: u8,
            shipPositionsOwn: [i8; MAX_SHIPS], shipPositionsEnemy: [i8; MAX_SHIPS],
            shipHpsEnemy: [i31; MAX_SHIPS]) -> (bool, u8, u8) {

            let position:i16 = shipPositionsOwn[currentShip];
            let proposedMove:u8 = 0;
            let minDistanceIndex:u8 = MAX_SHIPS;

            for i in range(0, MAX_SHIPS).rev() {
                let delta:u16 = (position - shipPositionsEnemy[enemyShip]).abs() as u16;

                if ((delta <= Ships[currentShip].range + Ships[currentShip].speed) &&
                    shipHpsEnemy[enemyShip] > 0) {

                    minDistanceIndex = enemyShip;
                    if (delta > Ships[currentShip].range) {
                        proposedMove = (delta - Ships[currentShip].range) as u8;
                    } else {
                        proposedMove = 0;
                    }

                    break;
                }
            }

            (minDistanceIndex < MAX_SHIPS, minDistanceIndex, proposedMove)
        }

        fn calculateDamage(&self, variables: [u16; MAX_SHIPS], variantsSource: [u8; MAX_SHIPS],
            variantsTarget: [u8; MAX_SHIPS], Ships: [Ship; MAX_SHIPS], source: u8,
            target: u8, sourceHp: u32) -> u32 {

            let attack: u16 = self.getAttackStat(Ships[source].attack.base,
                variantsSource[source]) + variables.source;
            let sourceShipsCount: u16 = (sourceHp / Ships[source].hp) as u16 + 1;
            let capDamage: u32 = (sourceShipsCount as u32) * (Ships[target].hp as u32);
            let damage: u32 = (attack - getDefenceStat(Ships[target].defence, variantsTarget[target])) as u32 *
                (sourceShipsCount as u32);

            if (((source as i8) - (target as i8) == 1) ||
                (source == 0 && target == Ships.length - 1)) {

                damage *= damage / 2;
            }

            return cmp::min(cmp::max(0, damage), capDamage);
        }

        fn logShoot(&self, round: u8, moves: &mut Vec<Move>, source: u8, target: u8,
            damage: u32, position: i8) {

            let newMove: Move = Move {
                moveType: 1,
                round: round,
                source: source,
                target: target,
                damage: damage,
                targetPosition: position
            };

            moves.push(newMove);
        }

        fn logMove(&self, round: u8, moves: &mut Vec<Move>, source: u8, targetPosition: i8) {
            let newMove: Move = Move {
                moveType: 2,
                round: round,
                source: source,
                targetPosition: targetPosition,
                target: 0,
                damage: 0
            };

            moves.push(newMove);
        }

        #[ink(message)]
        pub fn fight(&self, seed: u64, logMoves: bool, Ships: [Ship; MAX_SHIPS],
            selectionLhs: [u8; MAX_SHIPS], selectionRhs: [u8; MAX_SHIPS],
            variantsLhs: [u8; MAX_SHIPS], variantsRhs: [u8; MAX_SHIPS],
            commanderLhs: u8, commanderRhs: u8) {

            let shipPositionsLhs: [i8; MAX_SHIPS] = [10, 11, 12, 13];
            let shipPositionsRhs: [i8; MAX_SHIPS] = [-10, -11, -12, -13];
            let shipHpsLhs: [i32; MAX_SHIPS];
            let shipHpsRhs: [i32; MAX_SHIPS];
            let variablesLhs: [u16; MAX_SHIPS];
            let variablesRhs: [u16; MAX_SHIPS];

            for i in 0..MAX_SHIPS {
                shipHpsLhs[i] = (Ships[i].hp as i32) * (selectionLhs[i] as i32);
                shipHpsRhs[i] = (Ships[i].hp as i32) * (selectionRhs[i] as i32);
                variablesLhs[i] = (seed % Ships[i].attack.variable) as u16;
                variablesRhs[i] = ((seed / 2) % Ships[i].attack.variable) as u16;
            }

            let lhsMoves: Vec<Move>;
            let rhsMoves: Vec<Move>;

            for round in 0..MAX_ROUNDS {
                if (self.isDead(shipHpsLhs) || self.isDead(shipHpsRhs)) {
                    break;
                }

                for currentShip in 0..MAX_SHIPS {
                    let lhsHasTarget: bool = false;
                    let rhsHasTarget: bool = false;
                    let lhsDeadShip: bool = shipHpsLhs[currentShip] <= 0;
                    let rhsDeadShip: bool = shipHpsRhs[currentShip] <= 0;
                    let lhsDamage: u32 = 0;
                    let rhsDamage: u32 = 0;
                    let lhsTarget: uint8 = 0;
                    let rhsTarget: uint8 = 0;
                    let lhsDeltaMove: uint8 = 0;
                    let rhsDeltaMove: uint8 = 0;

                    if (!lhsDeadShip) {
                        (lhsHasTarget, lhsTarget, lhsDeltaMove) = self.getTarget(
                            Ships, currentShip, shipPositionsLhs, shipPositionsRhs, shipHpsRhs);

                        if (lhsHasTarget) {
                            lhsDamage = self.calculateDamage(variablesLhs, variantsLhs, variantsRhs,
                                Ships, currentShip, lhsTarget, shipHpsLhs[currentShip] as u32);

                            if (logMoves) {
                                self.logShoot(round, lhsMoves, currentShip, lhsTarget, lhsDamage,
                                    shipPositionsLhs[currentShip] - (lhsDeltaMove as i8));
                            }
                        } else {
                            if (logMoves) {
                                self.logMove(round, lhsMoves, currentShip, shipPositionsLhs[currentShip] -
                                    (Ships[currentShip].speed as i8));
                            }
                        }
                    }

                    if (!rhsDeadShip) {
                        (rhsHasTarget, rhsTarget, rhsDeltaMove) = self.getTarget(
                            Ships, currentShip, shipPositionsRhs, shipPositionsLhs, shipHpsLhs);

                        if (rhsHasTarget) {
                            rhsDamage = self.calculateDamage(variablesRhs, variantsRhs, variantsLhs,
                                Ships, currentShip, rhsTarget, shipHpsRhs[currentShip] as u32);
                            shipHpsLhs[rhsTarget] -= (rhsDamage as i32);

                            if (logMoves) {
                                self.logShoot(round, rhsMoves, currentShip, rhsTarget, rhsDamage,
                                    shipPositionsRhs[currentShip]);
                            }
                        } else {
                            shipPositionsRhs[currentShip] += (Ships[currentShip].speed as i8);

                            if (logMoves) {
                                self.logMove(round, rhsMoves, currentShip, shipPositionsRhs[currentShip]);
                            }
                        }
                    }

                    if (!lhsDeadShip) {
                        if (lhsHasTarget) {
                            shipHpsRhs[lhsTarget] -= (lhsDamage as i32);
                            shipPositionsLhs[currentShip] -= (lhsDeltaMove as i8);
                        } else {
                            shipPositionsLhs[currentShip] -= (Ships[currentShip].speed as i8);
                        }
                    }
                }
            }

            for i in (0..MAX_SHIPS) {
                let safeHpLhs: u32 = cmp::max(shipHpsLhs[i], 0) as u32;
                let safeHpRhs: u32 = cmp::max(shipHpsRhs[i], 0) as u32;
                shipsLostLhs[i] = (((selectionLhs[i] * Ships[i].hp) - safeHpLhs) / Ships[i].hp) as u8;
                shipsLostRhs[i] = (((selectionRhs[i] * Ships[i].hp) - safeHpRhs) / Ships[i].hp) as u8;
            }

            let totalRhsShips: u16 = 0;
            for i in (0..MAX_SHIPS) {
                totalRhsShips += selectionRhs[i];
            }

            let result: FightResult = FightResult {
                selectionLhs: selectionLhs,
                selectionRhs: selectionRhs,
                variantsLhs: variantsLhs,
                variantsRhs: variantsRhs,
                commanderLhs: commanderLhs,
                commanderRhs: commanderRhs,
                lhs: lhsMoves,
                rhs: rhsMoves,
                lhsDead: totalRhsShips > 0 && self.isDead(shipHpsLhs),
                rhsDead: self.isDead(shipHpsRhs),
                shipsLostLhs: shipsLostLhs,
                shipsLostRhs: shipsLostRhs,
                rounds: round,
                seed: seed
            };

            result
        }
    }


    #[cfg(test)]
    mod tests {
        use super::*;

        #[test]
        fn default_works() {
            let contract = GameEngineLibrary::default();
            assert_eq!(contract.get(), 0);
        }

        #[test]
        fn it_works() {
            let mut contract = GameEngineLibrary::new();
        }
    }
}
